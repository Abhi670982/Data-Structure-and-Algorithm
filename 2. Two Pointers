Two Pointers is an algorithmic technique where two variables (pointers) are used to traverse a data structure simultaneouslyâ€”usually an array or stringâ€”to reduce time complexity by avoiding nested loops.
Instead of checking every possible pair (O(nÂ²)), we move the pointers strategically based on conditions to solve the problem in O(n) time.

ðŸŸ¢ Easy Two Pointers (LeetCode)

Start with these to build confidence + pointer movement logic.
LeetCode 167 â€“ Two Sum II (Input Array Is Sorted)
LeetCode 344 â€“ Reverse String
LeetCode 125 â€“ Valid Palindrome
LeetCode 26 â€“ Remove Duplicates from Sorted Array
LeetCode 27 â€“ Remove Element
LeetCode 977 â€“ Squares of a Sorted Array
LeetCode 88 â€“ Merge Sorted Array
LeetCode 283 â€“ Move Zeroes
ðŸ‘‰ Focus here on:
left, right pointer movement
In-place modification
O(n) time solutions
ðŸŸ¡ Medium Two Pointers (LeetCode)
These test decision making + optimization.
LeetCode 11 â€“ Container With Most Water
LeetCode 15 â€“ 3Sum
LeetCode 16 â€“ 3Sum Closest
LeetCode 75 â€“ Sort Colors (Dutch National Flag)
LeetCode 3 â€“ Longest Substring Without Repeating Characters
LeetCode 209 â€“ Minimum Size Subarray Sum
LeetCode 713 â€“ Subarray Product Less Than K
LeetCode 42 â€“ Trapping Rain Water
LeetCode 392 â€“ Is Subsequence
ðŸ‘‰ Focus here on:
Why move left vs right
Handling duplicates
Sliding window variations


EASY LEVEL QUESTION -----------------------------------------------------------------------------------------------------------------------------------

Question 344: Reverse String

Solution: class Solution {
public:
    void reverseString(vector<char>& s) {
       int left = 0;
       int right = s.size()-1;

       while(left<right){
       swap(s[left], s[right]);
        right--;
        left++;
         
       } 
    }
};

Leetcode Question 1: Two Sum                                                                                 Date: 29|12|2025
Solution:

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {

        vector<pair<int,int>> arr;

        for (int i = 0; i < nums.size(); i++) {
            arr.push_back({nums[i], i});
        }

        sort(arr.begin(), arr.end());

        int left = 0;
        int right = arr.size() - 1;

        while (left < right) {
            int sum = arr[left].first + arr[right].first;

            if (sum == target) {
                return {arr[left].second, arr[right].second};
            } 
            else if (sum < target) {
                left++;
            } 
            else {
                right--;
            }
        }

        return {};
    }
};

MEDIUM LEVEL QUESTION -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Question 167: Two Sum II (Input Array Is Sorted)                                                                                 Date : 26|12|2025

Solution: class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0;
        int right = numbers.size() - 1;

        while (left < right) {
            int sum = numbers[left] + numbers[right];

            if (sum == target) {
                
                return {left + 1, right + 1};
            }
            else if (sum < target) {
                left++;
            }
            else {
                right--;
            }
        }

        return {};
    }
};


Question 15:  3Sum

Solution:

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ans;
        int n = nums.size();

        // Step 1: Sort the array
        sort(nums.begin(), nums.end());

        // Step 2: Fix one element
        for (int i = 0; i < n; i++) {

            // Skip duplicate fixed elements
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            int left = i + 1;
            int right = n - 1;

            // Step 3: Two pointers
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];

                if (sum == 0) {
                    ans.push_back({nums[i], nums[left], nums[right]});

                    // Skip duplicates for left and right
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;

                    left++;
                    right--;
                }
                else if (sum < 0) {
                    left++;   // need bigger sum
                }
                else {
                    right--;  // need smaller sum
                }
            }
        }

        return ans;
    }
};
