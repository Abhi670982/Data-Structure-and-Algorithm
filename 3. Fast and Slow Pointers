The fast and slow pointer technique uses two pointers moving at different speeds through a data structure (usually a linked list or array) to solve problems efficiently in O(n) time and O(1) space.
ðŸ§  Basic Idea
Slow pointer (slow) â†’ moves 1 step at a time
Fast pointer (fast) â†’ moves 2 steps at a time
Because of the speed difference, we can detect patterns like:
loops (cycles)
middle elements
intersections

ðŸš€ Why is it Powerful?
âœ… Avoids extra memory (no hash sets)
âœ… Faster than brute force
âœ… Very common in LeetCode + interviews

ðŸ¢ðŸ‡ Famous Name
This technique is also called Floydâ€™s Cycle Detection Algorithm
Slow = Tortoise ðŸ¢
Fast = Hare ðŸ‡


LeeCode Easy Question : 
Question : 876           Middle Of The LinkedList                                                                                                         04|01|2026

solution:

class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;

        while(fast!=nullptr && fast->next!=nullptr){
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
};


Question : 977. Squares of a Sorted Array                                                                    05|01|2026

Solution : 
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
       int n = nums.size();
       vector<int>result(n);

       int left = 0;
       int right = n-1;
       int pos = n-1;

       while(left<=right){
        if(nums[left] * nums[left] > nums[right] * nums[right]){
            result[pos] = nums[left] * nums[left];
            left++;
        }else{
            result[pos] = nums[right] * nums[right];
            right--;
        }
        pos--;
       }
       return result;
    }
};


Question no: 141 LinkedList Cycle                                                 07|01|2026
Solution: 

class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (!head || !head->next) return false;

        ListNode* slow = head;
        ListNode* fast = head->next;

        while (fast && fast->next) {
            if (slow == fast) return true;
            slow = slow->next;
            fast = fast->next->next;
        }

        return false;
    }
};


Question no: 202 Happy Number                                                    07|01|2026

Solution :
class Solution {
public:
    int nextNumber(int n) {
        int sum = 0;
        while (n > 0) {
            int digit = n % 10;
            sum += digit * digit;
            n /= 10;
        }
        return sum;
    }

    bool isHappy(int n) {
        int slow = n;
        int fast = n;

        do {
            slow = nextNumber(slow);               // 1 step
            fast = nextNumber(nextNumber(fast));  // 2 steps
        } while (slow != fast);

        return slow == 1;
    }
};
