The fast and slow pointer technique uses two pointers moving at different speeds through a data structure (usually a linked list or array) to solve problems efficiently in O(n) time and O(1) space.
ðŸ§  Basic Idea
Slow pointer (slow) â†’ moves 1 step at a time
Fast pointer (fast) â†’ moves 2 steps at a time
Because of the speed difference, we can detect patterns like:
loops (cycles)
middle elements
intersections

ðŸš€ Why is it Powerful?
âœ… Avoids extra memory (no hash sets)
âœ… Faster than brute force
âœ… Very common in LeetCode + interviews

ðŸ¢ðŸ‡ Famous Name
This technique is also called Floydâ€™s Cycle Detection Algorithm
Slow = Tortoise ðŸ¢
Fast = Hare ðŸ‡


LeeCode Easy Question : 
Question : 876           Middle Of The LinkedList                                                                                                         04|01|2026

solution:

class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;

        while(fast!=nullptr && fast->next!=nullptr){
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
};


Question : 977. Squares of a Sorted Array                                                                    05|01|2026

Solution : 
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
       int n = nums.size();
       vector<int>result(n);

       int left = 0;
       int right = n-1;
       int pos = n-1;

       while(left<=right){
        if(nums[left] * nums[left] > nums[right] * nums[right]){
            result[pos] = nums[left] * nums[left];
            left++;
        }else{
            result[pos] = nums[right] * nums[right];
            right--;
        }
        pos--;
       }
       return result;
    }
};
